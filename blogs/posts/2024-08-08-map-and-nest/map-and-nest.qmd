---
title: "Map and Nest"
author: "Rhian Davies"
date: "2023-08-08"
categories: [purrr, R, tutorial]
knitr:
  opts_chunk:
    fig.height: 2.5
    echo: true
    dev: png
    dev.args:
      bg: transparent
---

I want to share a framework that I like using occasionally for data analysis. It's the nest-and-map and it's helped me countless times when I'm working with related datasets. By combining [{purrr}](https://purrr.tidyverse.org/) mapping with [{tidyr}](https://tidyr.tidyverse.org/) nesting, I can keep raw data to hand while performing over different analyses. This allows me to easily track back from a summary or plot to the original raw data, ensuring everything is linked.

The main funtions we'll need are 

- `tidyr::nest()`
- `dplyr::mutate()`
- `purrr::map()`
- `purrr::walk()`


## Example on NHS workforce statistics 

```{r}
#| echo: false
source("helper-functions.R")
```

The [NHS workforce statistics](https://digital.nhs.uk/data-and-information/publications/statistical/nhs-workforce-statistics) are official statistics published monthly for England.

```{r}
staff_group <- readRDS(file = "workforce_staff_group.rds")
```

I want to perform an analysis for each of the 42 integrated care systems (ICS). The {tidyr} `nest()` function creates a list-column, where each cell contains a mini dataframe for each grouping.

Let's group by ICS, and call the nested data column `raw_data`.
```{r}
group_by_ics <- staff_group |>
    tidyr::nest(raw_data = -ics_name)
```

The new column is a list-column, with each cell containing an entire tibble of data relating to that individual ICS.

```{r}
#' echo: false
head(group_by_ics)
```

We can grab these mini datasets in the usual way and explore them interactively.

```{r}
group_by_ics$raw_data[[1]]
```

Next, let's apply some simple processing, say converting absolute numbers into percentages, to each of the ICSs in turn. We use `mutate()` to create a new list-column `staff_percent` and `map()` to apply the processing function to each cell in turn. ^[In this example, we actually didn't need to nest first. We could have performed the `mutate()` step on the full dataset.]

```{r}
processed_staff <-
group_by_ics |>
    dplyr::mutate(
        staff_percent = purrr::map(raw_data, convert_percent)
    )
```

Where I think this map-and-nest process really comes into its own is creating plots. Often, I find myself wanting to create a couple of different plots for each grouping, and then optionally save the plots with sensible names. Particularly in the analysis stage, I like having these plots in the same row as the raw data, so I can quickly compare and validate.

I've created [two functions](https://github.com/The-Strategy-Unit/data_science/tree/main/blogs/posts/2024-08-08-map-and-nest/helper-functions.R) `plot_barchart()` and `plot_waffle()`, which take the data and create charts. Again, using `mutate()` I can create a new column called `barchart` and I can `map()` the function `plot_barchart()`, applying it to each row at a time.

```{r}
graphs <-
processed_staff |>
    dplyr::mutate(
        barchart =  purrr::map(staff_percent, plot_barchart)
    ) 
```

The resulting column `barchart` is again a list-column, but this time instead of containing a tibble, it holds a ggplot object. A whole ggplot in a single cell. ^[This totally blew my mind the first time I saw it ðŸ¤¯.]

If we want to pass two arguments to our function, we can replace `map()` with `map2()`. Here we're using `map2()` to pass the `ics_name` column to use as a title in our waffle plot.

```{r}
graphs <-
processed_staff |>
    dplyr::mutate(
        waffle =  purrr::map2(raw_data, ics_name, ~plot_waffle(.x, title = .y))
    ) 
```

![An example bar chart plot](example_bar_chart.png)

## Putting it all together

All of these `mutate()` steps can actually be called in one step. Here's the full workflow again in full after a little refactor.
I've also used `pivot_longer()` to move the two plotting columns into a single plot column. This will make it easier for me to generate nice filenames, and save the plots.

```{r}
results <-
staff_group |>
    tidyr::nest(raw_data = -ics_name) |>
    dplyr::mutate(
        staff_percent = purrr::map(raw_data, convert_percent),
        barchart =  purrr::map(staff_percent, plot_barchart),
        waffle =  purrr::map2(raw_data, ics_name, ~plot_waffle(.x, title = .y))
    )     |>
    tidyr::pivot_longer(cols = c(barchart, waffle), names_to = "plot_type", values_to = "plot") |>
    dplyr::mutate(filename = glue::glue("{snakecase::to_snake_case(ics_name)}_{plot_type}.png"))
```

The `walk()` family of functions in {purrr} are used when the function you're applying does not return an object, but is being used for it's side-effect, for example reading or writing files.

Here we call `walk2()`, passing in both the filename column and the plots column are arguments to save all the plots.

```{r}
#| eval: false
purrr::walk2(
  results$filename,
  results$plot,
  \(filename, plot) ggplot2::ggsave(file.path("plots", filename), plot, width = 10, height = 6)
)
```

By keeping everything together in one nested structure, I personally find it much easier to keep track of my analyses.
If you're doing a more complex or permenant analysis, you might want to consider setting up a more formal data processing pipeline, and following RAP principals. 