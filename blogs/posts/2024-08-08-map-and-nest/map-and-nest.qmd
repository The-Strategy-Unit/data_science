---
title: "Map and Nest"
author: "Rhian Davies"
date: "2023-08-08"
categories: [purrr, R, tutorial]
knitr:
  opts_chunk:
    fig.height: 2.5
    echo: false
    dev: png
    dev.args:
      bg: transparent
---

I want to share a framework with you that I like using occasionally for data analysis. It's the nest-and-map and it's helped me countless times when I'm drowning in plots and data.

Basically we combine the [{purrr}](https://purrr.tidyverse.org/) mapping with [{tidyr}](https://tidyr.tidyverse.org/) nesting, which allows me to keep raw data close by while iterating over different analyses. This way, I can easily track back from a summary or plot to the original raw data, ensuring everything is linked and accessible.

I find it useful for when I want to keep a basic linkage between plots and raw data, without needing a full-blown data processing pipeline.

The main funtions we'll need are 

- `tidyr::nest()`
- `dplyr::mutate()`
- `purrr::map()`
- `purrr::walk()`


## Example on NHS workforce statistics 

The [NHS workforce statistics](https://digital.nhs.uk/data-and-information/publications/statistical/nhs-workforce-statistics) are official statistics published monthly for England. 


```{r}
staff_group <- readRDS(file = "workforce_staff_group.rds")
```

I want to perform an analysis for each of the 42 integrated care systems (ICS). The {tidyr} `nest()` function a creates a list-column which contains a mini dataframe just each group.

Let's group by ICS, and call the nested data column `raw_data`.
```{r}
group_by_ics <- staff_group |>
    tidyr::nest(raw_data = -ics_name)
```

```{r}
#' echo: false
head(group_by_ics)
```

We can grab these mini datasets in the usual way and explore them interactively.

```{r}
group_by_ics$raw_data[[1]]
```


Apply a function to every subset of the data. ^[In this example, we actually didn't need to nest first. We could have performed the `mutate()` step on the full dataset.]

```{r}
processed_staff <-
group_by_ics |>
    dplyr::mutate(
        staff_percent = purrr::map(raw_data, convert_percent)
    )
```


Where I think this map-and-nest process really comes into it's own is when I'm plotting. Often, I find myself wanting to create a couple of different plots for each grouping, and then optionally save the plots with sensible names. 

Particulary in the analysis stage, I like having these plots in the same row as the raw data, so I can quickly compare and validate, perhaps whilst pair programming.

I've created [two functions]() `plot_barchart()` and `plot_waffle()`, which take the data and create charts.

Using `mutuate()` I can create a new column called `barchart` and I can `map()` the function `plot_barchart()`, applying it to each row at a time.

```{r}
graphs <-
processed_staff |>
    dplyr::mutate(
        barchart =  purrr::map(staff_percent, plot_barchart)
    ) 
```

The resulting column `barchart` is again a list-column`, but this time instead of containing a tibble, it holds a ggplot object. A whole ggplot in a single cell. ^[This totally blew my mind the first time I saw it ðŸ¤¯.]

If we want to pass two arguments in, we can replace `map()` with `map2()`. Here we're using `map2() to pass the `ics_name` column as a title.

```{r}
graphs <-
processed_staff |>
    dplyr::mutate(
        waffle =  purrr::map2(raw_data, ics_name, ~plot_waffle(.x, title = .y))
    ) 
```


All of these `mutate()` steps can actually be called in one step. Here's the full workflow again in full after a little refactor.
I've also used `pivot_longer()` to move the two plotting columns into a single plot column. This will make it easier for me to add a nice filename, and save them all.

```{r}
results <-
staff_group |>
    tidyr::nest(raw_data = -ics_name) |>
    dplyr::mutate(
        staff_percent = purrr::map(raw_data, convert_percent),
        barchart =  purrr::map(staff_percent, plot_barchart),
        waffle =  purrr::map2(raw_data, ics_name, ~plot_waffle(.x, title = .y))
    )     |>
    tidyr::pivot_longer(cols = c(barchart, waffle), names_to = "plot_type", values_to = "plot") |>
    dplyr::mutate(filename = glue::glue("{snakecase::to_snake_case(ics_name)}_{plot_type}.png"))
```


The `walk()` family of functions in {purrr} are used when the function you're applying does not return an object, but is being used for it's side-effect, for exampe reading or writing.

Here we can call `walk2()`, passing in both the filename column and the plots column to save all the plots.

```{r}
#' eval: false
purrr::walk2(
  results$filename,
  results$plot,
  \(filename, plot) ggplot2::ggsave(file.path("plots", filename), plot, width = 10, height = 6)
)
```

By keeping everything together in one nested structure, I find it much easier to keep track of my analyses.
If you're doing a more complex or permenant analysis, you might want to consider setting up a more formal data processing pipeline, and following RAP principals. 