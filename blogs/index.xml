<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Data Science @ The Strategy Unit</title>
<link>https://the-strategy-unit.github.io/data_science/blogs/index.html</link>
<atom:link href="https://the-strategy-unit.github.io/data_science/blogs/index.xml" rel="self" type="application/rss+xml"/>
<description>Blogs from the Data Science Team at The Strategy Unit</description>
<generator>quarto-1.3.353</generator>
<lastBuildDate>Wed, 26 Apr 2023 00:00:00 GMT</lastBuildDate>
<item>
  <title>Reinstalling R Packages</title>
  <dc:creator>Tom Jemmett</dc:creator>
  <link>https://the-strategy-unit.github.io/data_science/blogs/posts/2023-04-26-reinstalling-r-packages.html</link>
  <description><![CDATA[ 



<p><a href="https://stat.ethz.ch/pipermail/r-announce/2023/000691.html">R 4.3.0 was released</a> last week. Anytime you update R you will probably find yourself in the position where no packages are installed. This is by design - the packages that you have installed may need to be updated and recompiled to work under new versions of R.</p>
<p>You may find yourself wanting to have all of the packages that you previously used, so one approach that some people take is to copy the previous library folder to the new versions folder. This isn‚Äôt a good idea and could potentially break your R install.</p>
<p>Another approach would be to export the list of packages in R before updating and then using that list after you have updated R. This can cause issues though if you install from places other than CRAN, e.g.&nbsp;bioconductor, or from GitHub.</p>
<p>Some of these approaches are discussed on the <a href="https://community.rstudio.com/t/reinstalling-packages-on-new-version-of-r/7670/4">RStudio Community Forum</a>. But I prefer an approach of having a ‚Äúspring clean‚Äù, instead only installing the packages that I know that I need.</p>
<p>I maintain a <a href="https://gist.github.com/tomjemmett/c105d3e0fbea7558088f68c65e68e1ed/">list of the packages that I used</a> as a gist. Using this, I can then simply run this script on any new R install. In fact, if you click the ‚Äúraw‚Äù button on the gist, and copy that url, you can simply run</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">source</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"https://gist.githubusercontent.com/tomjemmett/c105d3e0fbea7558088f68c65e68e1ed/raw/a1db4b5fa0d24562d16d3f57fe8c25fb0d8aa53e/setup.R"</span>)</span></code></pre></div>
<p>Generally, sourcing a url is a bad idea - the reason for this is if it‚Äôs not a link that you control, then someone could update the contents and run arbritary code on your machine. In this case, I‚Äôm happy to run this as it‚Äôs my own gist, but you should be mindful if running it yourself!</p>
<p>If you look at the script I first install a number of packages from CRAN, then I install packages that only exist on GitHub.</p>



 ]]></description>
  <category>git</category>
  <category>tutorial</category>
  <guid>https://the-strategy-unit.github.io/data_science/blogs/posts/2023-04-26-reinstalling-r-packages.html</guid>
  <pubDate>Wed, 26 Apr 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Alternative remote repositories</title>
  <dc:creator>Tom Jemmett</dc:creator>
  <link>https://the-strategy-unit.github.io/data_science/blogs/posts/2023-04-26_alternative_remotes.html</link>
  <description><![CDATA[ 



<p>It‚Äôs great when someone send‚Äôs you a pull request on GitHub to fix bugs or add new features to your project, but you probably always want to check the other persons work in someway before merging that pull request.</p>
<p>All of the steps below are intended to be entered via a terminal.</p>
<p>Let‚Äôs imagine that we have a GitHub account called example and a repository called test, and we use https rather than ssh.</p>
<pre><code>$ git remote get-url origin
# https://github.com/example/test.git</code></pre>
<p>Now, let‚Äôs say we have someone who has submitted a Pull Request (PR), and their username is friend. We can add a new remote for their fork with</p>
<pre><code>$ git remote add friend https://github.com/friend/test.git</code></pre>
<p>Here, I name the remote exactly as per the persons GitHub username for no other reason than making it easier to track things later on. You could name this remote whatever you like, but you will need to make sure that the remote url matches their repository correctly.</p>
<p>We are now able to checkout their remote branch. First, we will want to fetch their work:</p>
<pre><code># make sure to replace the remote name to what you set it to before
$ git fetch friend</code></pre>
<p>Now, hopefully they have commited to a branch with a name that you haven‚Äôt used. Let‚Äôs say they created a branch called <code>my_work</code>. You can then simply run</p>
<pre><code>$ git switch friend/my_work</code></pre>
<p>This should checkout the <code>my_work</code> branch locally for you.</p>
<p>Now, if they have happened to use a branch name that you are already using, or more likely, directly commited to their own <code>main</code> branch, you will need to do checkout to a new branch:</p>
<pre><code># replace friend as above to be the name of the remote, and main to be the branch
# that they have used
# replace their_work with whatever you want to call this branch locally
$ git checkout friend/main -b their_work</code></pre>
<p>You are now ready to run their code and check everything is good to merge!</p>
<p>Finally, If you want to clean up your local repository you can remove the new branch that you checked out and the new remote with the following steps:</p>
<pre><code># switch back to one of your branches, e.g. main
$ git checkout main

# then remove the branch that you created above
$ git branch -D their_work

# you can remove the remote
$ git remote remove friend</code></pre>



 ]]></description>
  <category>git</category>
  <category>tutorial</category>
  <guid>https://the-strategy-unit.github.io/data_science/blogs/posts/2023-04-26_alternative_remotes.html</guid>
  <pubDate>Wed, 26 Apr 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Creating a hotfix with git</title>
  <dc:creator>Tom Jemmett</dc:creator>
  <link>https://the-strategy-unit.github.io/data_science/blogs/posts/2023-03-24_hotfix-with-git.html</link>
  <description><![CDATA[ 



<p>I recently discovered a bug in a code-base which needed to be fixed and deployed back to production A.S.A.P., but since the last release the code has moved on significantly. The history looks something a bit like:</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="https://the-strategy-unit.github.io/data_science/blogs/posts/2023-03-24_hotfix-with-git_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>That is, we have a tag which is the code that is currently in production (which we need to patch), a number of commits after that tag to main (which were separate branches merged via pull requests), and a current development branch.</p>
<p>I need to somehow: 1. go back to the tagged release, 2. check that code out, 3. patch that code, 4. commit this change, but insert the commit before all of the new commits after the tag</p>
<p>There are at least two ways that I know to do this, one would be with an <a href="https://about.gitlab.com/blog/2020/11/23/keep-git-history-clean-with-interactive-rebase/">interactive rebase</a>, but I used a slightly longer method, but one I feel is a little less likely to get wrong.</p>
<p>Below are the step‚Äôs that I took. One thing I should note is this worked well for my particular issue because the change didn‚Äôt cause any merge conflicts later on.</p>
<section id="fixing-my-codebase" class="level2">
<h2 class="anchored" data-anchor-id="fixing-my-codebase">Fixing my codebase</h2>
<p>First, we need to checkout the tag</p>
<pre><code>git checkout -b hotfix v0.2.0</code></pre>
<p>This creates a new branch called <code>hotfix</code> off of the tag <code>v0.2.0</code>.</p>
<p>Now that I have the code base checked out at the point I need to fix, I can make the change that is needed, and commit the change</p>
<pre><code>git add [FILENAME]
git commit -m "fixes the code"</code></pre>
<p><em>(Obviously, I used the actual file name and gave a better commit message. I Promise üòù)</em></p>
<p>Now my code is fixed, I create a new tag for this ‚Äúrelease‚Äù, as well as push the code to production (this step is omitted here)</p>
<pre><code>git tag v0.2.1 -m "version 0.2.0"</code></pre>
<p>At this point, our history looks something like</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="https://the-strategy-unit.github.io/data_science/blogs/posts/2023-03-24_hotfix-with-git_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>What we want to do is break the link between main and <code>v0.2.0</code>, instead attaching to<code>v0.2.1</code>. First though, I want to make sure that if I make a mistake, I‚Äôm not making it on the main branch.</p>
<pre><code>git checkout main
git checkout -b apply-hotfix</code></pre>
<p>Then we can fix our history using the rebase command</p>
<pre><code>git rebase hotfix</code></pre>
<p>What this does is it rolls back to the point where the branch that we are rebasing (<code>apply-hotfix</code>) and the <code>hotfix</code> branch both share a common commit (<code>v0.2.0</code> tag). It then applies the commits in the <code>hotfix</code> branch, before reapplying the commits from <code>apply-hotfix</code> (a.k.a. the <code>main</code> branch).</p>
<p>One thing to note, if you have any merge conflicts created by your fix, then the rebase will stop and ask you to fix the merge conflicts. There is some information in the GitHub doc‚Äôs for [resolving merge conflicts after a Git rebase][2].</p>
<p>[2]: https://docs.github.com/en/get-started/using-git/resolving-merge-conflicts-after-a-git-rebase</p>
<p>At this point, we can check that the commit history looks correct</p>
<pre><code>git log v0.2.0..HEAD</code></pre>
<p>If we are happy, then we can apply this to the <code>main</code> branch. I do this by renaming the <code>apply-hotfix</code> branch as <code>main</code>. First, you have to delete the <code>main</code> branch to allow us to rename the branch.</p>
<pre><code>git branch -D main
git branch -m main</code></pre>
<p>We also need to update the other branches to use the new main branch</p>
<pre><code>git checkout branch
git rebase main</code></pre>
<p>Now, we should have a history like</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="https://the-strategy-unit.github.io/data_science/blogs/posts/2023-03-24_hotfix-with-git_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" width="672"></p>
</div>
</div>


</section>

 ]]></description>
  <category>git</category>
  <category>tutorial</category>
  <guid>https://the-strategy-unit.github.io/data_science/blogs/posts/2023-03-24_hotfix-with-git.html</guid>
  <pubDate>Fri, 24 Mar 2023 00:00:00 GMT</pubDate>
</item>
</channel>
</rss>
